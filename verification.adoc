
include::template.adoc[]

Процесс верификации модели является важной и неотъемлемой частью разработки любой современной СБИС. Финальной частью разработки микросхемы 
является изготовление на специальной фабрике (TSMC, например). В отличие от программного обеспечения, 
изготовленная микросхема не может быть изменена, что сильно увеличивает цену ошибки. 
На данный момент верификация делится на несколько типов и имеет свои методологии.

=== Верификация в процессе разработки 

==== Функциональная верификация 

Основная задача функциональной верификации - проверка функционала системы, проверка каждого состаяния и по возможности 
достижение функционального покрытия 100% (каждый бит должен пройти переходы из 0 в 1 и наоборот)[11]. Результатом функциональной верификации 
является заключение о работоспособности ситемы, в особенности возможность выдержать рандомизированные тесты. 

Функциональная верификация имеет несколько методологий, каждая из которых позволяет использовать сильные стороны различных инструментов 
либо упрощает тестирование сложных объектов. 

===== UVM 

UVM(Universal Verification Methodology) - универальная методология верификации. Данная метология подразумевает создание универсального тестового 
окружения для конкретных тестовых задач(например, измерить частоту изменения сигнала в определенном узле). 
Созданное тестовое окружение может использоваться много раз, подключаясь к разным моделям в разных проектах. 
Большим преимуществом такого подхода является возможность быстрой верификации
(при условии, что уже существуют все готовые тестовые блоки окружения). Схема тестового окружения изображена на рис.2. 

[#UVM_schematic]
.Схема UVM тестирования
image::UVM.jpg[UVM]

===== Cocotb

Cocotb представляет собой фреймворк на языке python, который позволяет использовать код на python для тестирования RTL модели[12]. 
Основная идея данного метода: перенос верификации из плоскости электроники в плоскость программного обеспечения. Фреймворк позволяет 
пользоваться всеми инструментами языка, что делает тестирование более гибким процессом, а также существенно снижает порог входа для 
инженеров и программистов.  

===== Verilator

Verilator является одновременно и инструментом и методом тестирования моделей. Программа переводит синтезируемый RTL код в классы на языке С++.
Дальнейшее тестирование осуществляется также на языке С++. Данный подход позволяет пользоваться всеми возможностями языка, 
но при этом отсутствует переход в область программного обеспечения, 
так как управление сигналами осуществялется вручную, либо из тестовых окружений, написанных на Verilog[13]. 
Плюсами данного подхода является очень маленькое время обработки и симуляции. Верификация с помощью Verilator
является самым быстрым способом симулировать большой проект описания аппаратуры
(некоторые тесты показывают выигрышь во времени в 2 раза или более по сравнению с лучшими проприетарными САПР). В качестве минусов данного способа 
можно выдилить необходимость глубокого понимания работы языка С++, 
а также высокий порог входа в сборку проектов и доступность ПО только для ОС Linux.

===== Assertion based verification 

Верификация с помощью конструкций assertion может являться как вспомогающим, так и основным способом верификации в зависимости от сложности и 
объема проекта. В данном подходе создаются точечные ограничения, либо целый набор правил работы устройства.[11] В случае нарушения любого из правил 
симуляция останавливается и выдается сообшщение об ошибке, которое заранее прописано разработчиком или верификатором. Данный способ помогает в отладке, потому что сразу показывает где произошла ошибка, в какой момент, и что к ней привело, но при этом написание крупных наборов правил 
довольно сложный процесс, что делает данный подход не самым популярным. 

==== Формальная и статический анализ

Часто источниками ошибок может быть сам код, и несмотря на компилируемость, неправильно транслироваться в логические функции. Для того чтобы 
избежать таких ошибок применяется формальная верификация и статичекий анализ кода. 
Перед началом разработки, разработчики договариваются о правилах написания кода, а также пишут специальные правила для программы linter, 
которая следит за исполнением этих договоренностей. Данный подход 
позволяет избежать ошибок еще до попадания модели к верификатору[11]. 
Сейчас в качестве программ linter применяются мощные программные средства, например, Cadence Hal или JasperGold.


==== Прототипирование

В качестве одного из способов верификации может выступать прототипирование микросхемы с помощью FPGA[11]. 
В ПЛИС загружается прошивка крупного блока или всей системы в целом (например микропроцессорная система, микроконтроллер), 
после чего создается программа на языке С или языке ассемблера, которая полностью проверяет функционал системы. 
Такой тип верификации полезен, чтобы на практике оценить возможные отклонения системы от идеальности, также такой подход помогает 
верифицировать схемы без четкого разделения на программную и аппаратную части(например, USB). 

==== Физическая верификация

Во время разработки часто возникает вопрос о синтезируемости и реализуемости модели при заданных параметрах. 
Чтобы удостовериться или опровергнуть реализуемость применяется физическая верификация. Данный тип верификации проводится на этапе синтеза.
Разработанная модель синтезируется в логические вентили, после чего на созданные вентили накладываются задержки, случайные неидеальности, 
условия асинхронного расхождения и возможные гонки сигналов на линиях[11]. На этапе физического моделирования создается netlist логических вентилей и SDF файл условий. 
Также на данном этапе возникаает понятие угла (corner), которое дополняет моделирование различными внешними факторами, например, 
температурными условиями и напряжением питания. 
В случае особых требований к параметрам работы устройства осуществляется проверка на просадки питания и максимальное количество срабатывания битов. 

=== Производственная верификация

Производственная верификация (DFT - design for test) служит способом проверки работоспособности устройства после его изготовления. 
Для проверки готовой микросхемы на этапе разработки и тестирования в модель вносится большое количество входов и выходов. Цель данного этапа 
заключается в нахождении производственных ошибок технологии. На этапе верификации через специальные входы и выходы прозваниваются все регистры и логические блоки, чтобы найти битые транзисторы и ячейки памяти и определить работоспособность схемы. 

